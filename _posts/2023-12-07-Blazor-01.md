---
title: Przerabiamy Blazora
tags: [Programowanie, Blazor]
style: fill
color: info 
description: Wspólna nauka Blazora, krok po kroku.
---
<br>

W świecie programowania .NET perspektywa tworzenia front-endu bez opuszczania komfortowego środowiska Visual Studio, dodatkowo wykorzystując jedynie C#, wydaje się być niezwykle atrakcyjna.
Blazor to technologia, która realizuje tę obietnicę, umożliwiając rozwijanie aplikacji internetowych pozostając w granicach dobrze znanych narzędzi i języków programowania.

W nadchodzących wpisach skupię się na jego szczegółowym badaniu. 
Rozpoczniemy od eksploracji podstawowych konceptów, które są fundamentem tej technologii, a następnie, krok po kroku, przejdziemy do bardziej zaawansowanych funkcji.

Wspólna podróż przez ten proces pozwoli zarówno Tobie, jak i mnie, zgłębić tajniki tego fascynującego frameworka.


<h4 style="color:#003366"><b>Co jest fajne w Blazor?</b></h4> 

<h5 style="color:#003366">Jednolity Język Programowania:</h6> 
Możliwość tworzenia zarówno frontendu, jak i backendu w języku C#.

<h5 style="color:#003366">Komponentowy Model UI:</h6> 
Blazor korzysta z komponentowego podejścia do budowania interfejsu użytkownika (podobnie jak React czy Angular), co ułatwia ponowne użycie kodu i zarządzanie nim.

<h5 style="color:#003366">Współdzielenie Kodu:</h6> 
Możliwość współdzielenia kodu pomiędzy klientem, a serwerem, co znacząco zmniejsza jego dublowanie i ułatwia zarządzanie.

<h5 style="color:#003366">Elastyczność, Skalowalność i Niezawodność:</h6> 
Blazor jest nie tylko elastyczny, pozwalając na tworzenie aplikacji od prostych stron po złożone rozwiązania, ale dzięki stabilnemu i dojrzałemu ekosystemowi .NET, zapewnia również odporność i niezawodność niezbędne dla aplikacji na każdą skalę.

<h5 style="color:#003366">Integracja z Istniejącymi Aplikacjami .NET:</h6> 
Blazor obiecuję łatwą integrację z istniejącymi aplikacjami .NET, umożliwiając stopniowe dodawanie nowoczesnych interfejsów użytkownika do legacy code.

<h5 style="color:#003366">Wsparcie dla WebAssembly i Server-Side Rendering:</h6> 
Blazor umożliwia programistom wybór najlepszego podejścia do budowy aplikacji.  
Mogą wykorzystać WebAssembly do uruchamiania kodu C# bezpośrednio w przeglądarce dla maksymalnej wydajności lub zdecydować się na Server-Side, który przeprowadza renderowanie po stronie serwera, redukując obciążenie klienta i przyspieszając początkowe ładowanie strony. 
Obie opcje oferują elastyczność i wydajność, dostosowane do specyficznych wymagań projektowych.

<h5 style="color:#003366">Narzędzia deweloperskie:</h6> 
Możemy wykorzystywać Hot Reload, umożliwiając natychmiastową aktualizację interfejsu przy zmianie kodu, a wsparcie Visual Studio dla profilowania i diagnostyki aplikacji przewyższa możliwości konsoli przeglądarki, oferując zaawansowane opcje debugowania. Dodatkowo, łatwość integracji z bogatym wyborem bibliotek .NET redukuje czas potrzebny na rozwój i testowanie nowych funkcji.

<h5 style="color:#003366">Społeczność:</h6>  
Jako produkt Microsoftu, Blazor cieszy się silnym wsparciem, regularnymi aktualizacjami oraz dużą społecznością użytkowników.

<h5 style="color:#003366">Jednolity Stos Technologiczny:</h6> 
Używając Blazor, firmy mogą ujednolicić swój stos technologiczny wokół .NET, co ułatwia zarządzanie zespołami programistów i zmniejsza koszty szkoleniowe.

<h5 style="color:#003366">Open Source :</h6> 
Blazor jest open source, co oznacza, że ma transparentny rozwój i szeroką współpracę ze strony społeczności.

<h4 style="color:#003366"><b>Historia Blazor w pigułce</b></h4> 

<h5 style="color:#003366">Początki (2017):</h6>  
Blazor został po raz pierwszy zaprezentowany przez Steve'a Sandersona, pracownika Microsoft, na konferencji NDC w Oslo. Wtedy był to eksperymentalny projekt, który pozwalał na uruchamianie C# w przeglądarkach za pomocą WebAssembly.

<h5 style="color:#003366">Eksperymentalny rozwój (2017-2018):</h6>   
W tym okresie Microsoft zbierał opinie i rozwijał Blazor jako otwarte oprogramowanie (open-source). Społeczność deweloperów zaczęła aktywnie uczestniczyć w rozwoju tego narzędzia.

<h5 style="color:#003366">Blazor Server (wrzesień 2019):</h6>   
Blazor Server stał się pierwszą oficjalnie wspieraną wersją Blazor, która została włączona do .NET Core 3.0. 

<h5 style="color:#003366">Blazor WebAssembly (maj 2020):</h6>   
Wersja Blazor, która pozwala na uruchamianie C# bezpośrednio w przeglądarkach klientów za pomocą WebAssembly, została wypuszczona jako część .NET Core 3.1. Od tego momentu programiści mogli tworzyć pełnoprawne Single Page Applications (SPA) wykorzystując tylko C# bez potrzeby pisania JavaScript.

<h5 style="color:#003366">Integracja z .NET 5 i .NET 6 (2020-2021): </h6>  
Blazor kontynuował integrację z kolejnymi wersjami .NET, dostarczając nowe funkcjonalności, poprawki i optymalizacje.

<h5 style="color:#003366">Blazor Hybrid i MAUI (2021-2022):</h6>   
W ramach .NET 6 i zbliżającej się wersji .NET MAUI (Multi-platform App UI), Blazor rozszerzył swoje możliwości na aplikacje hybrydowe, które mogą działać na wielu platformach (desktop, mobile) przy użyciu tego samego kodu co w aplikacjach webowych.

Blazor jest ciągle rozwijany i dostaje nowe funkcje, które ułatwiają tworzenie bogatych aplikacji internetowych. Dzięki Blazor, deweloperzy .NET mają teraz możliwość budowania aplikacji webowych w znany im sposób, co sprawia, że jest on coraz popularniejszym wyborem w świecie programowania.

<h4 style="color:#003366"><b>Zastosowanie Blazor</b></h4> 

Blazor świetnie nadaje się do wykorzystania w projektach typu:
* aplikacje jednostronicowe (SPA),
* rozwiązania SaaS,
* tworzenie aplikacji wewnętrznych dla przedsiębiorstw,
* aplikacje E-commerce,
* aplikacje edukacyjne czy portale szkoleniowe,
* migracja aplikacji desktopowych na platformy webowe.

<h4 style="color:#003366"><b>Wyzwania i Ograniczenia Blazor</b></h4> 

<h5 style="color:#003366">Wymagania Dotyczące Przeglądarki dla Blazor WebAssembly</h6>  
Blazor WebAssembly wymaga nowoczesnych przeglądarek do działania. Starsze przeglądarki, które nie obsługują WebAssembly, nie będą w stanie uruchomić aplikacji, co może ograniczać dostępność aplikacji dla niektórych użytkowników.

<h5 style="color:#003366">Rozmiar początkowego ładunku</h6>  
Aplikacje Blazor WebAssembly mogą mieć duży początkowy ładunek ze względu na konieczność przesłania .NET runtime do przeglądarki użytkownika. To może prowadzić do dłuższego czasu ładowania aplikacji przy pierwszym uruchomieniu.

<h5 style="color:#003366">Obsługa SEO i Czas Ładowania</h6>  
Aplikacje Blazor, szczególnie w modelu WebAssembly, mogą stawiać wyzwania w zakresie optymalizacji pod kątem wyszukiwarek (SEO) i czasu ładowania strony, co jest kluczowe dla aplikacji internetowych.

<h5 style="color:#003366">Zarządzanie Stanem w Blazor Server</h6>  
W modelu Blazor Server zarządzanie stanem aplikacji może być trudniejsze ze względu na stan bezstanowy protokołu HTTP i konieczność utrzymywania stanu między żądaniami. (TODO-TM?)

<h5 style="color:#003366">Integracja z Innymi Technologiami Front-End </h6>  


Blazor może przysparzać trudności w integracji z niektórymi istniejącymi bibliotekami i narzędziami JavaScript, co wymaga dodatkowych prac w celu zapewnienia pełnej kompatybilności.


Podsumowując, Blazor stanowi przełomową technologię .NET, oferując programistom możliwość tworzenia zaawansowanych aplikacji internetowych, wykorzystując dobrze znany język C# oraz narzędzia Visual Studio.

Ta technologia otwiera nowe perspektywy w projektowaniu aplikacji webowych, jednak, jak każda technologia, posiada swoje wyzwania i ograniczenia, które będą przedmiotem naszych dalszych dyskusji. 

W nadchodzących wpisach, zgłębimy te kwestie, a także będziemy analizować przypadki użycia, najlepsze praktyki oraz sposoby pokonywania napotykanych trudności.

Zapraszam do śledzenia kolejnych wpisów, które będą nie tylko źródłem cennych informacji, ale również inspiracją do eksplorowania możliwości, jakie oferuje Blazor.




> "Clean code is simple and direct. Clean code reads like well-written prose." - Grady Booch

Clean code to podejście do programowania, które kładzie nacisk na tworzenie czytelnego i łatwo zarządzalnego kodu.
Zbiór praktyk wprowadzonych przez Roberta C. Martina w jego książce o tej samej nazwie. <br><br>
Jest to absolutna podstawa w kontekście codziennych zadań programistycznych, aczkolwiek nader często jest zaniedbywana. W środowisku, gdzie nowe języki, frameworki i narzędzia pojawiają się z zawrotną prędkością, umiejętność pisania czytelnego i utrzymywalnego kodu pozostaje stała i ceniona. <br>

Przestrzeganie zasad Clean Code jest jak dbanie o własne zdrowie - możesz zignorować je teraz, ale uwierz mi, za kilka lat będziesz płacić wysoką cenę. <br><br>

TODO - mem <br>

Po krótce postaram się opisać część z zasad, którymi powinniśmy się kierować przy realizowaniu kolejnych zmian w naszych projektach.

<h6 style="color:#4CBB17">Łatwość zrozumienia przez innych programistów, jak i przez samego twórcę.</h6> 
Piszmy kod w ten sposób, abyśmy po paru miesiącach nie zastanawiali się kto jest autorem napisanego ulepa.
TODO przejście do podpunktów:

* <p  style="color:#4CBB17">Klarowne nazewnictwo:</p>
    >"You should name a variable using the same care with which you name a first-born child." <br>- Robert C. Martin  

    * <span  style="color:#4CBB17">Zmienne: </span>
    Nazwy zmiennych powinny jasno wskazywać, co jest przechoywane w danej zmiennej. <br>
    Trzymajmy się opisowości i odzwierciedlania roli zmiennej w kontekście metody, klasy czy aplikacji.
      
        ```cs
        "Zła praktyka"
        string n;
        "Dobra praktyka"
        string name;
        ```

    * <span  style="color:#4CBB17">Funkcje:</span>
    Precyzyjny opis zadania lub działania. <br>
        ```cs
        "Zła praktyka"
        void DoStuff();
        
        "Dobra praktyka"
        void SaveCustomerDetails();
        ```    
    * <span  style="color:#4CBB17">Klasy:</span>
    * <span  style="color:#4CBB17">Moduły i pakiety:</span>
    * <span  style="color:#4CBB17">Komentarze i dokumentacja:</span>
    Komentarze są potrzebne wtedy kiedy kod nie jest wystarczająco jasny;
        
        ```cs
        "Zła praktyka"
        // Zwiększ o 1
        i= i + 1;

        "Dobra praktyka"
        i++;
        ```

* <span  style="color:#4CBB17">Zasada jednej odpowiedzialności.</span><br>
SRP - Każda funkcja lub klasa powinna mieć jedną, dobrze zdefiniowaną rolę i nie robić zbyt wielu rzeczy.
        
     ```cs
    "Zła praktyka"
    void ProcessOrder()
    {
        // walidacja
        // zapis do bazy danych
        // wysyła e-maila
    }
        
    "Dobra praktyka"
    void ProcessOrder()
    {
        ValidateOrder();
        SaveOrder();
        SendConfirmationEmail();
    }
    ```   

* <span  style="color:#4CBB17">Odrzucanie zbędnej złożoności</span><br>
Prostota kodu jest kluczowa. Kod powinien być jak najprostszy i pozbawiony niepotrzebnej złożoności. Unikaj nadmiernych warunków, zagnieżdżeń czy *ifologii*. <br>
Zasada KISS (Keep it small and simple lub Keep it simple stupid)

     ```cs
    "Zła praktyka"

    string ProcessWords(string input)
    {
        // Używamy regex i LINQ, choć wystarczyłaby pętla
        return Regex.Replace(input, @"\s+", " ")
                    .Split(' ')
                    .Where(s => !string.IsNullOrEmpty(s))
                    .Aggregate((a, b) => a + " " + b);
    }
    
    "Dobra praktyka"

    string ProcessWords(string input)
    {
        var words = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return string.Join(" ", words);
    }
    ```

* <span  style="color:#4CBB17">Ograniczenie poziomu zagnieżdżania</span><br>
    Staraj się ograniczyć poziom zagnieżdżenia w funkcjach, używając wcześniejszych return'ów w nich.
    
    ```cs

    "Zła praktyka"

    void SomeFunction(int value)
    {
        if (value > 0)
        {
            // Jakiś kod
            if (value < 100)
            {
                // Jakiś kod
            }
        }
    }

    "Dobra praktyka"

    void SomeFunction(int value)
    {
        if (value <= 0)
        {
            return;
        }

        // Jakiś kod

        if (value >= 100)
        {
            return;
        }

        // Jakiś kod
    }
    ```

* <span  style="color:#4CBB17">Brak nadmiernych powtórzeń</span><br>
    Unikaj duplikacji kodu.

    ```cs
    
    "Zła praktyka"

    void DisplayOrderDetails()
    {
        Console.WriteLine("Order name: " + order.Name);
        Console.WriteLine("Order amount: " + order.Amount);
    }

    void PrintOrderDetails()
    {
        Console.WriteLine("Order name: " + order.Name);
        Console.WriteLine("Order amount: " + order.Amount);
    }

    "Dobra praktyka"

    void DisplayOrderDetails()
    {
        ShowOrderDetails();
    }

    void PrintOrderDetails()
    {
        ShowOrderDetails();
    }

    void ShowOrderDetails()
    {
        Console.WriteLine("Order name: " + order.Name);
        Console.WriteLine("Order amount: " + order.Amount);
    }
    ```

Kod powinien być czytelny jak dobrze napisana książka. W przeciwnym razie, zamiast zanurzyć się w fascynującej fabule algorytmów i funkcji, będziesz błądził w labiryncie nieczytelnych linijek, tracąc drogocenny czas i cierpliwość. Clean Code jest jak język, który umożliwia płynną komunikację między programistami. Zrozumiały, elegancki kod zaprasza do dalszej lektury, ułatwiając życie nie tylko Tobie, ale i każdemu, kto kiedykolwiek będzie musiał zmierzyć się z Twoim "literackim dziełem". Czas zacząć pisać kod jak bestsellery! <br><br>

Oczywiście, to tylko początek serii wpisów dotyczących czystości w naszym kodzie. Clean Code to temat na tyle obszerny i fascynujący, że jedno spotkanie z nim to zdecydowanie za mało. Dlatego resztę postanowiłem wydzielić do osobnych artykułów. <br> <br> 
W kolejnych odsłonach zajmiemy się takimi zagadnieniami jak refactoring, SOLID, testowalność i wiele innych. <br>

Proponowana literatura:
1. Clean Code

Powiązane zagadnienia:
Dług technologiczny, Robert C. Martin, wujek bob,




MARKDOWN:

```cs
public void Test()
{
    Console.WriteLine("Fenced code blocks ftw!");
}
```

```json
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```

```sql
SELECT * FROM dbo.Test;
```

```html
<html>
<head>
<script src="https://unpkg.com/react@15/dist/react.min.js"> </script><script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js">
</script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">

    /*
    ADD REACT CODE HERE
    */

    </script>
</body>
</html>
```

```js
// hello.js
function getGreeting (name) {
  return `Hello, ${name}!`
}

const message = getGreeting('world')
console.log(message)
```

## NAGŁÓWEK

`<div>` `#root` `<script type="text/babel">`

{% include elements/highlight.html text="A component can change its internal state directly. It can not change its props directly." %}

This is called **escaping**.

> Note: To make this work, we also had to bind the `this` keyword to the `updateMessage` method. Otherwise we couldn’t have accessed `this` in the method.


{% gist 53b03db644353af05279f8fe3eea1a09 %}


In today’s world of more succint programming languages, we need a different “hello world” to demonstrate language features better. Here’s what I propose:

This simple example demonstrates a few more things than printing strings:

- How to write a function with an argument
- Returning values from functions
- How to use variables
- The naming convention for functions (camelCase versus snake_case)
- String concatenation
- Comments


Inspiracja: [LINK DO ŹRÓDŁA](https://TOJESTŹRÓDŁO.COM)