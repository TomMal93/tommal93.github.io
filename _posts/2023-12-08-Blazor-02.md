---
title: Przerabiamy Blazora
tags: [Programowanie, Blazor]
style: fill
color: info 
description: Wspólna nauka Blazora, krok po kroku.
---
<hr style="height: 1px; background-color: orange;">
Poprzedni wpis skupiał się na krótkim wprowadzeniu do Blazora opisując zarys charakterystyki, historii czy zastosowań tego frameworka.
W tym zajmiemy się zdefiniowaniem tej technologii oraz pojęć jej pokrewnych. Dodatkowo spróbujemy opisać strukturę defaultowego projektu w Visual Studio.

<hr style="height: 1px; background-color: orange;">


<h4 style="color:#007bff"><b>Definicja Blazor</b></h4> 

Blazor to framework do tworzenia aplikacji webowych, który jest częścią platformy .NET. Umożliwia on pisanie klienta oraz logiki frontendowej w języku C# zamiast tradycyjnego JavaScriptu. 
Framework Blazor dzieli się na dwa główne typy - Server-Side oraz WebAssembly.
Aby opisać oba z nich najpłynniej będzie przejść do ich porównania:

<hr style="height: 1px; background-color: orange;">


<h4 style="color:#007bff"><b>Server-Side a WebAssembly</b></h4> 

<table border="1">
  <tr>
    <th>Server-Side</th>
    <th>WebAssembly</th>
  </tr>
  <tr>
    <td>Kod C# działa na serwerze, a aktualizacje interfejsu użytkownika oraz zdarzenia są przesyłane przez połączenie SignalR.</td>
    <td>Kod C# jest kompilowany do WebAssembly i uruchamiany bezpośrednio w przeglądarce klienta. To pozwala na działanie aplikacji offline i redukuje obciążenie serwera.</td>
  </tr>
  <tr>
    <td><strong>Obciążenie serwera</strong><br>Każda akcja użytkownika na stronie wymaga komunikacji z serwerem, co zwiększa obciążenie serwera i może generować większy ruch sieciowy.</td>
    <td>Po pierwszym załadowaniu, większość pracy wykonuje przeglądarka klienta, co zmniejsza obciążenie serwera.</td>
  </tr>
  <tr>
    <td><strong>Opóźnienia i wydajność</strong><br>Wydajność zależy od szybkości połączenia sieciowego między klientem a serwerem oraz od szybkości odpowiedzi serwera.</td>
    <td>Wydajność jest uzależniona od mocy obliczeniowej klienta i może być różna na różnych urządzeniach.</td>
  </tr>
  <tr>
    <td><strong>Dostępność offline</strong><br>Wymaga ciągłego połączenia z serwerem; jeśli połączenie zostanie przerwane, aplikacja przestaje działać.</td>
    <td>Możliwość tworzenia aplikacji działających offline, tak długo dopóki będą w pamięci przeglądarki. Po początkowym załadowaniu aplikacji, cała logika aplikacji jest na stronie klienta.</td>
  </tr>


Zasoby i ładowanie początkowe
Początkowe ładowanie jest szybsze, ponieważ przesyłane są tylko HTML i minimalny zestaw danych niezbędnych do nawiązania połączenia przez SignalR.
Działanie pomiędzy requestami będzie zdecydowanie wolniejsze niż w przypadku WebAssembly.
Wymaga przesłania na początku większych ilości danych (kod aplikacji w WebAssembly), co może wydłużyć początkowe ładowanie.
Optymalizacja pod kątem wyszukiwarek internetowych jest utrudniona, niski wynik w PageRank w kontekście SEO.


Zabezpieczenia
Logika biznesowa pozostaje na serwerze, co zapewnia lepszą kontrolę nad dostępem do wrażliwych części aplikacji.
 Kod klienta jest w pełni dostępny w przeglądarce, co oznacza, że wrażliwe dane i logika biznesowa mogą być potencjalnie narażone.


Łatwość skalowania
Może wymagać skomplikowanego skalowania, szczególnie gdy liczba użytkowników rośnie, co zwiększa liczbę połączeń SignalR, które serwer musi obsłużyć.
Łatwiej skalować, ponieważ przerzucamy odpowiedzialność na klienta i jego możliwości sprzętowe - serwery głównie dostarczają statyczne pliki.
Korzystanie z .NET
Pełna kompatybilność, możliwość użycia wszystkich bibliotek dostępnych w .NET.
Istnieją pewne ograniczenia. 
Nie wszystkie biblioteki .NET’owe będą możliwe do skompilowania w WebAssembly, ale ich lista jest rozwijana.
Dodatkowe zalety
Lepsze wsparcie SEO,
nie wszystkie przeglądarki wspierają WebAssembly, a Server-Side wspiera zapewnia działanie aplikacji na wszystkich z nich
Hostowanie stron statycznych, możliwość użycia podejścia Serverless.


Zastosowanie
Kiedy mamy dużo nowych użytkowników,
sklep internetowy,
portal aukcyjny
Kiedy mamy zdefiniowaną liczbę zarejestrowanych użytkowników znających produkt,
Usługa typu SASS

</table>

Hybrid wykorzystywany jest bardziej jako aplikacja desktopowa czy mobilna. 
Ma gwarantować dostęp do zasobów urządzenia, na którym jest uruchomiona, czyli dostęp do kamery czy mikrofonu itp. TODO


Domyślna struktura projektu:

Server-Side							WebAssembly (ASP.NET Core Hosted)



<h6 style="color:#0056b3">Properties:</h6>   
* Folder zawierający właściwości projektu, takie jak plik konfiguracyjny launchSettings.json, który określa sposób uruchamiania aplikacji.
 
<h6 style="color:#0056b3">wwwroot:</h6>
* Folder zawierający statyczne zasoby projektu, takie jak HTML, CSS, JavaScript, obrazy itd.

<h6 style="color:#0056b3">Data:</h6>

* Folder zawierający klasy i plików związane z danymi i logiką biznesową.

<h6 style="color:#0056b3">Pages:</h6>
 
* Folder zawierający komponenty Razor dla poszczególnych stron aplikacji.

<h6 style="color:#0056b3">Shared:</h6>

* Folder z komponentami współdzielonymi, takimi jak layouty i nawigacja

<h6 style="color:#0056b3">_Imports.razor:</h6>

* W obu projektach wykorzystuje się go do globalnego importowania usingów

<h6 style="color:#0056b3">App.razor</h6>

* Główny komponent aplikacji, definiujący routing i jej zachowania na najwyższym poziomie.

<h6 style="color:#0056b3">appsettings.json</h6>

* Plik konfiguracyjny używany do przechowywania ustawień aplikacji (ścieżki, pliki konfiguracyjne, connection stringi etc.)

<h6 style="color:#0056b3">Program.cs</h6>

* skondensowany Startup.cs i Program.cs, punkt wejścia aplikacji. Zawiera konfigurację i inicjalizację hosta serwera/ WebAssembly i inicjalizację aplikacji Blazor.
