---
title: Przerabiamy Blazora
tags: [Programowanie, Blazor]
style: fill
color: info 
description: Wspólna nauka Blazora, krok po kroku.
---
<hr style="height: 1px; background-color: orange;">
Poprzedni wpis skupiał się na krótkim wprowadzeniu do Blazora opisując zarys charakterystyki, historii czy zastosowań tego frameworka.
W tym zajmiemy się zdefiniowaniem tej technologii oraz pojęć jej pokrewnych. Dodatkowo spróbujemy opisać strukturę defaultowego projektu w Visual Studio.

<hr style="height: 1px; background-color: orange;">


<h4 style="color:#007bff"><b>Definicja Blazor</b></h4> 

Blazor to framework do tworzenia aplikacji webowych, który jest częścią platformy .NET. Umożliwia on pisanie klienta oraz logiki frontendowej w języku C# zamiast tradycyjnego JavaScriptu. 
Framework Blazor dzieli się na dwa główne typy - Server-Side oraz WebAssembly.
Aby opisać oba z nich najpłynniej będzie przejść do ich porównania:

<table>
  <tr>
    <th style="text-align: center; border: none;">Server-Side</th>
    <th style="text-align: center; border: none;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" class="small-th"><strong>Uruchamianie kodu</strong></th>
  </tr>
  <tr>
    <td class="table-row-content">Kod C# działa na serwerze, a aktualizacje interfejsu użytkownika oraz zdarzenia są przesyłane przez połączenie SignalR.</td>
    <td class="table-row-content">Kod C# jest kompilowany do WebAssembly i uruchamiany bezpośrednio w przeglądarce klienta. To pozwala na działanie aplikacji offline i redukuje obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; border: none;"><strong>Obciążenie serwera</strong></th>
  </tr>
  <tr>
    <td class="table-row-content">Każda akcja użytkownika na stronie wymaga komunikacji z serwerem, co zwiększa obciążenie serwera i może generować większy ruch sieciowy.</td>
    <td class="table-row-content">Po pierwszym załadowaniu, większość pracy wykonuje przeglądarka klienta, co zmniejsza obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Opóźnienia i wydajność</strong></th>
  </tr>
  <tr>
    <td>Wydajność zależy od szybkości połączenia sieciowego między klientem a serwerem oraz od szybkości odpowiedzi serwera.</td>
    <td>Wydajność jest uzależniona od mocy obliczeniowej klienta i może być różna na różnych urządzeniach.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dostępność offline</strong></th>
  </tr>
  <tr>
    <td>Wymaga ciągłego połączenia z serwerem; jeśli połączenie zostanie przerwane, aplikacja przestaje działać.</td>
    <td>Możliwość tworzenia aplikacji działających offline, tak długo dopóki będą w pamięci przeglądarki. Po początkowym załadowaniu aplikacji, cała logika aplikacji jest na stronie klienta.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zasoby i ładowanie początkowe</strong></th>
  </tr>
  <tr>
    <td>Początkowe ładowanie jest szybsze, ponieważ przesyłane są tylko HTML i minimalny zestaw danych niezbędnych do nawiązania połączenia przez SignalR. Działanie pomiędzy requestami będzie zdecydowanie wolniejsze niż w przypadku WebAssembly.</td>
    <td>Wymaga przesłania na początku większych ilości danych (kod aplikacji w WebAssembly), co może wydłużyć początkowe ładowanie. Optymalizacja pod kątem wyszukiwarek internetowych jest utrudniona, niski wynik w PageRank w kontekście SEO.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zabezpieczenia</strong></th>
  </tr>
  <tr>
    <td>Logika biznesowa pozostaje na serwerze, co zapewnia lepszą kontrolę nad dostępem do wrażliwych części aplikacji.</td>
    <td>Kod klienta jest w pełni dostępny w przeglądarce, co oznacza, że wrażliwe dane i logika biznesowa mogą być potencjalnie narażone.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Łatwość skalowania</strong></th>
  </tr>
  <tr>
    <td>Może wymagać skomplikowanego skalowania, szczególnie gdy liczba użytkowników rośnie, co zwiększa liczbę połączeń SignalR, które serwer musi obsłużyć.</td>
    <td>Łatwiej skalować, ponieważ przerzucamy odpowiedzialność na klienta i jego możliwości sprzętowe - serwery głównie dostarczają statyczne pliki.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Korzystanie z .NET</strong></th>
  </tr>
  <tr>
    <td>Pełna kompatybilność, możliwość użycia wszystkich bibliotek dostępnych w .NET.</td>
    <td>Istnieją pewne ograniczenia. Nie wszystkie biblioteki .NET’owe będą możliwe do skompilowania w WebAssembly, ale ich lista jest rozwijana.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dodatkowe zalety</strong></th>
  </tr>
  <tr>
    <td>Lepsze wsparcie SEO, nie wszystkie przeglądarki wspierają WebAssembly, a Server-Side wspiera zapewnia działanie aplikacji na wszystkich z nich.</td>
    <td>Hostowanie stron statycznych, możliwość użycia podejścia Serverless.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zastosowanie</strong></th>
  </tr>
  <tr>
    <td>Kiedy mamy dużo nowych użytkowników, sklep internetowy, portal aukcyjny</td>
    <td>Kiedy mamy zdefiniowaną liczbę zarejestrowanych użytkowników znających produkt, Usługa typu SASS</td>
</tr>
</table>

Hybrid wykorzystywany jest bardziej jako aplikacja desktopowa czy mobilna. 
Ma gwarantować dostęp do zasobów urządzenia, na którym jest uruchomiona, czyli dostęp do kamery czy mikrofonu itp. TODO

<hr style="height: 1px; background-color: orange;">

Domyślna struktura projektu:

Server-Side							WebAssembly (ASP.NET Core Hosted)



<h6 style="color:#0056b3">Properties:</h6>   
Zawiera właściwości projektu, takie jak plik konfiguracyjny launchSettings.json, który określa sposób uruchamiania aplikacji.
 
<h6 style="color:#0056b3">wwwroot:</h6>
Zawiera statyczne zasoby projektu, takie jak HTML, CSS, JavaScript, obrazy itd.

<h6 style="color:#0056b3">Data:</h6>
Zawiera klasy i plików związane z danymi i logiką biznesową.

<h6 style="color:#0056b3">Pages:</h6>
Zawiera komponenty Razor dla poszczególnych stron aplikacji.

<h6 style="color:#0056b3">Shared:</h6>
Zawiera komponenty współdzielone, takie jak layouty i nawigacja.

<h6 style="color:#0056b3">_Imports.razor:</h6>
W obu projektach wykorzystuje się go do globalnego importowania usingów

<h6 style="color:#0056b3">App.razor</h6>
Główny komponent aplikacji, definiujący routing i jej zachowania na najwyższym poziomie.

<h6 style="color:#0056b3">appsettings.json</h6>
Plik konfiguracyjny używany do przechowywania ustawień aplikacji (ścieżki, pliki konfiguracyjne, connection stringi etc.)

<h6 style="color:#0056b3">Program.cs</h6>
Skondensowany Startup.cs i Program.cs, punkt wejścia aplikacji. Zawiera konfigurację i inicjalizację hosta serwera/ WebAssembly i inicjalizację aplikacji Blazor.



<table style= "border-collapse: collapse;">
  <tr>
    <th style="text-align: center;">Server-Side</th>
    <th style="text-align: center;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Uruchamianie kodu</strong></th>
  </tr>
  <tr>
    <td>Kod C# działa na serwerze, a aktualizacje interfejsu użytkownika oraz zdarzenia są przesyłane przez połączenie SignalR.</td>
    <td>Kod C# jest kompilowany do WebAssembly i uruchamiany bezpośrednio w przeglądarce klienta. To pozwala na działanie aplikacji offline i redukuje obciążenie serwera.</td>
  </tr>
</table>


| Nagłówek 1 | Nagłówek 2 |
|------------|------------|
|  Wartość 2 |
|------------|------------|
| Wiersz 2   | Wartość 3  |
| Wiersz 3   | Wartość 5  |
