---
title: Przerabiamy Blazora
tags: [Programowanie, Blazor]
style: fill
color: info 
description: Wspólna nauka Blazora, krok po kroku.
---
<hr style="height: 1px; background-color: orange;">
Poprzedni wpis skupiał się na krótkim wprowadzeniu do Blazora opisując zarys charakterystyki, historii czy zastosowań tego frameworka.
W tym zajmiemy się zdefiniowaniem tej technologii oraz pojęć jej pokrewnych. Dodatkowo spróbujemy opisać strukturę defaultowego projektu w Visual Studio.
<br>

<h4 style="color:#007bff"><b>Definicja Blazor</b></h4> 

Blazor to framework do tworzenia aplikacji webowych, który jest częścią platformy .NET. Umożliwia on pisanie klienta oraz logiki frontendowej w języku C# zamiast tradycyjnego JavaScriptu. 
Framework Blazor dzieli się na dwa główne typy - Server-Side oraz WebAssembly.
Aby opisać oba z nich najpłynniej będzie przejść do ich porównania:

<table>
  <tr>
    <th style="text-align: center;  width:50%;">Server-Side</th>
    <th style="text-align: center;  width:50%;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Uruchamianie kodu</strong></th>
  </tr>
  <tr>
    <td >Kod C# działa na serwerze, a aktualizacje interfejsu użytkownika oraz zdarzenia są przesyłane przez połączenie SignalR.</td>
    <td >Kod C# jest kompilowany do WebAssembly i uruchamiany bezpośrednio w przeglądarce klienta. To pozwala na działanie aplikacji offline i redukuje obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Obciążenie serwera</strong></th>
  </tr>
  <tr>
    <td >Każda akcja użytkownika na stronie wymaga komunikacji z serwerem, co zwiększa obciążenie serwera i może generować większy ruch sieciowy.</td>
    <td >Po pierwszym załadowaniu, większość pracy wykonuje przeglądarka klienta, co zmniejsza obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Opóźnienia i wydajność</strong></th>
  </tr>
  <tr>
    <td >Wydajność zależy od szybkości połączenia sieciowego między klientem a serwerem oraz od szybkości odpowiedzi serwera.</td>
    <td >Wydajność jest uzależniona od mocy obliczeniowej klienta i może być różna na różnych urządzeniach.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dostępność offline</strong></th>
  </tr>
  <tr>
    <td >Wymaga ciągłego połączenia z serwerem; jeśli połączenie zostanie przerwane, aplikacja przestaje działać.</td>
    <td >Możliwość tworzenia aplikacji działających offline, tak długo dopóki będą w pamięci przeglądarki. Po początkowym załadowaniu aplikacji, cała logika aplikacji jest na stronie klienta.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zasoby i ładowanie początkowe</strong></th>
  </tr>
  <tr>
    <td >Początkowe ładowanie jest szybsze, ponieważ przesyłane są tylko HTML i minimalny zestaw danych niezbędnych do nawiązania połączenia przez SignalR. Działanie pomiędzy requestami będzie zdecydowanie wolniejsze niż w przypadku WebAssembly.</td>
    <td >Wymaga przesłania na początku większych ilości danych (kod aplikacji w WebAssembly), co może wydłużyć początkowe ładowanie. Optymalizacja pod kątem wyszukiwarek internetowych jest utrudniona, niski wynik w PageRank w kontekście SEO.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zabezpieczenia</strong></th>
  </tr>
  <tr>
    <td >Logika biznesowa pozostaje na serwerze, co zapewnia lepszą kontrolę nad dostępem do wrażliwych części aplikacji.</td>
    <td >Kod klienta jest w pełni dostępny w przeglądarce, co oznacza, że wrażliwe dane i logika biznesowa mogą być potencjalnie narażone.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Łatwość skalowania</strong></th>
  </tr>
  <tr>
    <td >Może wymagać skomplikowanego skalowania, szczególnie gdy liczba użytkowników rośnie, co zwiększa liczbę połączeń SignalR, które serwer musi obsłużyć.</td>
    <td >Łatwiej skalować, ponieważ przerzucamy odpowiedzialność na klienta i jego możliwości sprzętowe - serwery głównie dostarczają statyczne pliki.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Korzystanie z .NET</strong></th>
  </tr>
  <tr>
    <td >Pełna kompatybilność, możliwość użycia wszystkich bibliotek dostępnych w .NET.</td>
    <td >Istnieją pewne ograniczenia. Nie wszystkie biblioteki .NET’owe będą możliwe do skompilowania w WebAssembly, ale ich lista jest rozwijana.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dodatkowe zalety</strong></th>
  </tr>
  <tr>
    <td >Lepsze wsparcie SEO, nie wszystkie przeglądarki wspierają WebAssembly, a Server-Side wspiera zapewnia działanie aplikacji na wszystkich z nich.</td>
    <td >Hostowanie stron statycznych, możliwość użycia podejścia Serverless.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zastosowanie</strong></th>
  </tr>
  <tr>
    <td >Kiedy mamy dużo nowych użytkowników, sklep internetowy, portal aukcyjny</td>
    <td >Kiedy mamy zdefiniowaną liczbę zarejestrowanych użytkowników znających produkt, Usługa typu SASS</td>
</tr>
</table>

Istnieje jeszcze wersja Hybrid wykorzystywana bardziej jako aplikacja desktopowa czy mobilna. Ma gwarantować dostęp do zasobów urządzenia, na którym jest uruchomiona, czyli dostęp do kamery czy mikrofonu.
Natomiast w tym kursie nie będziemy zajmować się tą wersją Blazora.

<hr style="height: 1px; background-color: orange;">

<h4 style="color:#007bff"><b>Domyślna struktura projektu</b></h4> 

Poniższe zrzuty ekranu przedstawiają strukturę dwóch typów projektów Blazor.

W strukturze po stronie serwera wszystkie pliki są zawarte w jednym projekcie. Jest zaprojektowany do uruchamiania na serwerze, a aktualizacje UI są wysyłane za pośrednictwem połączenia SignalR.

Struktura WebAssembly jest podzielona na trzy projekty: Client, Server i Shared. 
Klient zawiera strony i wwwroot, podczas gdy Server ma kontrolery, co podkreśla jego rolę w obsłudze żądań HTTP. 
Projekt Shared jest wspólny dla obu i zazwyczaj dotyczy wspólnych modeli lub danych.

Główne różnice dotyczą organizacji projektu i obecności kontrolerów w projekcie serwera WebAssembly, które nie są potrzebne w projekcie po stronie serwera ze względu na bezpośrednią obsługę żądań w komponentach Razor.

<div style="display: flex; justify-content: space-between;">
    <figure class="figure w-100">
        <img src="..\assets\images\Struktura projektu Server Side.PNG" class="figure-img img-fluid rounded" alt="">
        <figcaption class="figure-caption text-center">Server-Side</figcaption>
    </figure>
    <figure class="figure w-100">
        <img src="..\assets\images\Struktura projektu WASM.PNG" class="figure-img img-fluid rounded" alt="">
        <figcaption class="figure-caption text-center">WebAssembly (ASP.NET Core Hosted)</figcaption>
    </figure>
</div>

Poniżej wymienimy wspólne punkty obu z nich.

<table>
  <tr>
    <th style="text-align: center;">Elementy wspólne</th>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>Properties</strong></th>
  </tr>
  <tr>
    <td >Zawiera właściwości projektu, takie jak plik konfiguracyjny launchSettings.json, który określa sposób uruchamiania aplikacji.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>wwwroot</strong></th>
  </tr>
  <tr>
    <td >Zawiera statyczne zasoby projektu, takie jak HTML, CSS, JavaScript, obrazy itd.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>Data</strong></th>
  </tr>
  <tr>
    <td >Zawiera klasy i plików związane z danymi i logiką biznesową.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>Pages</strong></th>
  </tr>
  <tr>
    <td >Zawiera komponenty Razor dla poszczególnych stron aplikacji.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>Shared</strong></th>
  </tr>
  <tr>
    <td >Zawiera komponenty współdzielone, takie jak layouty i nawigacja.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>_Imports.razor</strong></th>
  </tr>
  <tr>
    <td >W obu projektach wykorzystuje się go do globalnego importowania usingów.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>App.razor</strong></th>
  </tr>
  <tr>
    <td >Główny komponent aplikacji, definiujący routing i jej zachowania na najwyższym poziomie.</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>appsettings.json</strong></th>
  </tr>
  <tr>
    <td >Plik konfiguracyjny używany do przechowywania ustawień aplikacji (ścieżki, pliki konfiguracyjne, connection stringi etc.).</td>
  </tr>
  <tr>
    <th style="text-align: center; background-color:#0056b3; "><strong>Program.cs</strong></th>
  </tr>
  <tr>
    <td >Skondensowany Startup.cs i Program.cs, punkt wejścia aplikacji. Zawiera konfigurację i inicjalizację hosta serwera/ WebAssembly i inicjalizację aplikacji Blazor.</td>
  </tr>
</table>

Wspólne punkty zostały omówione, więc przejdziemy teraz do głównych różnic pomiędzy układami domyślnych projektów obu podejść.

<table>
  <tr>
    <th colspan="2" style="text-align: center; border-bottom: solid gray;">Różnice</th>
  </tr>
  <tr>
    <th style="text-align: center;  width:50%;">Server-Side</th>
    <th style="text-align: center;  width:50%;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Modele</strong></th>
  </tr>
  <tr>
    <td >Lokalizacja modeli to folder: "Data"</td>
    <td >Lokalizacja modeli to projekt: "Shared"</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Serwisy/Kontrolery</strong></th>
  </tr>
  <tr>
    <td >Serwisy znajdują się również jak modele w folderze: "Data"</td>
    <td >Kontrolery znajdująsię w projekcie Server w folderze: "Controllers"</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Początkowy punkt aplikacji</strong></th>
  </tr>
  <tr>
    <td >Początkowy punkt aplikacji to plik: "_Host.cshtml"</td>
    <td >Początkowy punkt aplikacji to plik: "index.html" w folderze "wwwroot"</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>_Layout.cshtml</strong></th>
  </tr>
  <tr>
    <td >Jest używany jako główny szablon układu (layout) dla całej aplikacji. Działa podobnie jak w innych projektach ASP.NET Core MVC lub Razor Pages, gdzie definiuje wspólny układ strony, taki jak nagłówek, stopka, i menu nawigacyjne.</td>
    <td >Zamiast _Layout.cshtml, Blazor WebAssembly wykorzystuje komponenty Razor do definiowania układu. Przykładowo, plik MainLayout.razor w folderze Shared pełni podobną funkcję, definiując wspólny układ dla różnych stron.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>blazor.webassembly.js</strong></th>
  </tr>
  <tr>
    <td >Brak; nie jest potrzebny, ponieważ logika jest wykonywana po stronie serwera.</td>
    <td >Skrypt JS w folderze wwwroot, odpowiedzialny za inicjalizację aplikacji WebAssembly.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; "><strong>Folder Controllers</strong></th>
  </tr>
  <tr>
    <td >Taka potrzeba nie występuje, ponieważ cała logika aplikacji jest skoncentrowana i wykonywana po stronie serwera.</td>
    <td >Obsługa komunikacji między warstwą front-endu a back-endu</td>
  </tr>
</table>

