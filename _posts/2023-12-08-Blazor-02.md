---
title: Przerabiamy Blazora
tags: [Programowanie, Blazor]
style: fill
color: info 
description: Wspólna nauka Blazora, krok po kroku.
---
<hr style="height: 1px; background-color: orange;">
Poprzedni wpis skupiał się na krótkim wprowadzeniu do Blazora opisując zarys charakterystyki, historii czy zastosowań tego frameworka.
W tym zajmiemy się zdefiniowaniem tej technologii oraz pojęć jej pokrewnych. Dodatkowo spróbujemy opisać strukturę defaultowego projektu w Visual Studio.

<hr style="height: 1px; background-color: orange;">


<h4 style="color:#007bff"><b>Definicja Blazor</b></h4> 

Blazor to framework do tworzenia aplikacji webowych, który jest częścią platformy .NET. Umożliwia on pisanie klienta oraz logiki frontendowej w języku C# zamiast tradycyjnego JavaScriptu. 
Framework Blazor dzieli się na dwa główne typy - Server-Side oraz WebAssembly.
Aby opisać oba z nich najpłynniej będzie przejść do ich porównania:

<table>
  <tr>
    <th style="text-align: center; border: none;">Server-Side</th>
    <th style="text-align: center; border: none;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; border: none;"><strong>Uruchamianie kodu</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Kod C# działa na serwerze, a aktualizacje interfejsu użytkownika oraz zdarzenia są przesyłane przez połączenie SignalR.</td>
    <td style="border: none;">Kod C# jest kompilowany do WebAssembly i uruchamiany bezpośrednio w przeglądarce klienta. To pozwala na działanie aplikacji offline i redukuje obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3; border: none;"><strong>Obciążenie serwera</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Każda akcja użytkownika na stronie wymaga komunikacji z serwerem, co zwiększa obciążenie serwera i może generować większy ruch sieciowy.</td>
    <td style="border: none;">Po pierwszym załadowaniu, większość pracy wykonuje przeglądarka klienta, co zmniejsza obciążenie serwera.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Opóźnienia i wydajność</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Wydajność zależy od szybkości połączenia sieciowego między klientem a serwerem oraz od szybkości odpowiedzi serwera.</td>
    <td style="border: none;  vertical-align: top;">Wydajność jest uzależniona od mocy obliczeniowej klienta i może być różna na różnych urządzeniach.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dostępność offline</strong></th>
  </tr>
  <tr>
    <td style="border: none; vertical-align: top;">Wymaga ciągłego połączenia z serwerem; jeśli połączenie zostanie przerwane, aplikacja przestaje działać.</td>
    <td style="border: none;">Możliwość tworzenia aplikacji działających offline, tak długo dopóki będą w pamięci przeglądarki. Po początkowym załadowaniu aplikacji, cała logika aplikacji jest na stronie klienta.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zasoby i ładowanie początkowe</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Początkowe ładowanie jest szybsze, ponieważ przesyłane są tylko HTML i minimalny zestaw danych niezbędnych do nawiązania połączenia przez SignalR. Działanie pomiędzy requestami będzie zdecydowanie wolniejsze niż w przypadku WebAssembly.</td>
    <td style="border: none;">Wymaga przesłania na początku większych ilości danych (kod aplikacji w WebAssembly), co może wydłużyć początkowe ładowanie. Optymalizacja pod kątem wyszukiwarek internetowych jest utrudniona, niski wynik w PageRank w kontekście SEO.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zabezpieczenia</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Logika biznesowa pozostaje na serwerze, co zapewnia lepszą kontrolę nad dostępem do wrażliwych części aplikacji.</td>
    <td style="border: none;">Kod klienta jest w pełni dostępny w przeglądarce, co oznacza, że wrażliwe dane i logika biznesowa mogą być potencjalnie narażone.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Łatwość skalowania</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Może wymagać skomplikowanego skalowania, szczególnie gdy liczba użytkowników rośnie, co zwiększa liczbę połączeń SignalR, które serwer musi obsłużyć.</td>
    <td style="border: none;">Łatwiej skalować, ponieważ przerzucamy odpowiedzialność na klienta i jego możliwości sprzętowe - serwery głównie dostarczają statyczne pliki.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Korzystanie z .NET</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Pełna kompatybilność, możliwość użycia wszystkich bibliotek dostępnych w .NET.</td>
    <td style="border: none;">Istnieją pewne ograniczenia. Nie wszystkie biblioteki .NET’owe będą możliwe do skompilowania w WebAssembly, ale ich lista jest rozwijana.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Dodatkowe zalety</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Lepsze wsparcie SEO, nie wszystkie przeglądarki wspierają WebAssembly, a Server-Side wspiera zapewnia działanie aplikacji na wszystkich z nich.</td>
    <td style="border: none;">Hostowanie stron statycznych, możliwość użycia podejścia Serverless.</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Zastosowanie</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Kiedy mamy dużo nowych użytkowników, sklep internetowy, portal aukcyjny</td>
    <td style="border: none;">Kiedy mamy zdefiniowaną liczbę zarejestrowanych użytkowników znających produkt, Usługa typu SASS</td>
</tr>
</table>

Hybrid wykorzystywany jest bardziej jako aplikacja desktopowa czy mobilna. 
Ma gwarantować dostęp do zasobów urządzenia, na którym jest uruchomiona, czyli dostęp do kamery czy mikrofonu itp. TODO

<hr style="height: 1px; background-color: orange;">

Domyślna struktura projektu:


![Opis zdjęcia](..\assets\images\Struktura projektu Server Side.PNG)
{% include elements/figure.html image="..\assets\images\Struktura projektu Server Side.PNG" caption="Several years ago we were definitely in the room on the right but we’ve moved a lot closer to the room on the left." %}


<figure class="figure w-100">
  <img src="..\assets\images\Struktura projektu Server Side.PNG" class="figure-img img-fluid rounded" alt="">
  {%- if include.caption -%}
    <figcaption class="figure-caption text-center">{{ include.caption }}</figcaption>
  {%- endif -%}
</figure>

{% raw %}
{% include elements/figure.html image="..\assets\images\Struktura projektu Server Side.PNG" caption="The Ocean" %}
{% endraw %}

{% raw %}
{% include elements/figure.html image="\..\assets\images\Struktura projektu Server Side.PNG" caption="The Ocean" %}
{% endraw %}

Server-Side							WebAssembly (ASP.NET Core Hosted)



* <h6 style="color:#0056b3">Properties:</h6>   
Zawiera właściwości projektu, takie jak plik konfiguracyjny launchSettings.json, który określa sposób uruchamiania aplikacji.
 
* <h6 style="color:#0056b3">wwwroot:</h6>
Zawiera statyczne zasoby projektu, takie jak HTML, CSS, JavaScript, obrazy itd.

* <h6 style="color:#0056b3">Data:</h6>
Zawiera klasy i plików związane z danymi i logiką biznesową.

* <h6 style="color:#0056b3">Pages:</h6>
Zawiera komponenty Razor dla poszczególnych stron aplikacji.

* <h6 style="color:#0056b3">Shared:</h6>
Zawiera komponenty współdzielone, takie jak layouty i nawigacja.

* <h6 style="color:#0056b3">_Imports.razor:</h6>
W obu projektach wykorzystuje się go do globalnego importowania usingów

* <h6 style="color:#0056b3">App.razor</h6>
Główny komponent aplikacji, definiujący routing i jej zachowania na najwyższym poziomie.

* <h6 style="color:#0056b3">appsettings.json</h6>
Plik konfiguracyjny używany do przechowywania ustawień aplikacji (ścieżki, pliki konfiguracyjne, connection stringi etc.)

* <h6 style="color:#0056b3">Program.cs</h6>
Skondensowany Startup.cs i Program.cs, punkt wejścia aplikacji. Zawiera konfigurację i inicjalizację hosta serwera/ WebAssembly i inicjalizację aplikacji Blazor.



<table style= "border-collapse: collapse;">
  <tr>
    <th style="text-align: center;">Server-Side</th>
    <th style="text-align: center;">WebAssembly</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Modele</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Data</td>
    <td style="border: none;">Blazor.WebAssembly.Shared</td>
  </tr>
  
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Serwisy/Kontrolery</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Data</td>
    <td style="border: none;">Blazor.WebAssembly.Server - Controllers</td>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Początkowy punkt aplikacji</strong></th>
  </tr>
  <tr>
    <td style="border: none;">_Host.cshtml</td>
    <td style="border: none;">/wwwroot/index.html</td>
  </tr>
  
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>_Layout.cshtml</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Jest używany jako główny szablon układu (layout) dla całej aplikacji. Działa podobnie jak w innych projektach ASP.NET Core MVC lub Razor Pages, gdzie definiuje wspólny układ strony, taki jak nagłówek, stopka, i menu nawigacyjne.</td>
    <td style="border: none;">Zamiast _Layout.cshtml, Blazor WebAssembly wykorzystuje komponenty Razor do definiowania układu. Przykładowo, plik MainLayout.razor w folderze Shared pełni podobną funkcję, definiując wspólny układ dla różnych stron.</td>
  </tr>
  
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>blazor.webassembly.js</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Brak; nie jest potrzebny, ponieważ logika jest wykonywana po stronie serwera.</td>
    <td style="border: none;">Skrypt JS w folderze wwwroot, odpowiedzialny za inicjalizację aplikacji WebAssembly.</td>
  </tr>
  
  <tr>
    <th colspan="2" style="text-align: center; background-color:#0056b3"><strong>Folder Controllers</strong></th>
  </tr>
  <tr>
    <td style="border: none;">Taka potrzeba nie występuje, ponieważ cała logika aplikacji jest skoncentrowana i wykonywana po stronie serwera.</td>
    <td style="border: none;">Obsługa komunikacji między warstwą front-endu a back-endu</td>
  </tr>
</table>